# 所有权
基本原则:
- 一块内存必须被唯一的变量所拥有
## 1 值语义
数据存放在**栈区**，赋值时发生按位拷贝，拷贝后新对象与原对象相互独立，称为**值语义**。值语义类型发生赋值后将生成一份新的数据，对新数据的操作不会影响原数据，反之亦然。
### 1.1 栈区拷贝
- 值语义类型，数据存放在**栈区**
- 赋值时发生栈区**拷贝**
- 按位拷贝后，新对象与原对象相互独立，不相关
```rust
fn main() {
    let x: i32 = 10;
    let y: i32 = x; //  发生值语义赋值，x 和 y 各自持有一份数据，可以被同时访问
    println!("{x} {y}");
}
```
&nbsp;
### 1.2 Copy Trait
在Rust中，一个类型是否属于值语义，取决于类型是否实现了`Copy`特质。
- 以下类型在标准库中已经实现了`Copy`特质

| 值语义类型 | 举例 |
|---|---|
|数值标量类型|`i32`<br>`f64`<br>`usize`<br>`bool`<br>`char`<br>...|
|共享引用与可变引用|`&i32`<br>`&mut String`|
|裸指针|-|
|所有元素都实现了`Copy`特质的元组|`(1, 3.14)`|
|所有元素都实现了`Copy`特质的数组|`[1, 3.14]`|
|显式实现Copy特质的结构体|`#[derive(Clone, Copy)]`<br>`struct Val { x: i32, y: f64, }`|
|显式实现Copy特质的枚举|`#[derive(Clone, Copy)]`<br>`enum YesOrNo Val { YES, NO, }`|

&nbsp;
- 结构体不会默认实现`Copy`特质，即使它的所有元素都实现了`Copy`特质
- 使用属性宏`#[derive(Clone, Copy)]`为结构体或枚举显式实现Copy特质
```rust
    struct Val {
        x: i32,
        y: f64,
    }

    let v1 = Val{x:1, y:3.14};      //  发生移动
    let v2 = v1;
    println!("{}, {}", v1.x, v1.y);     // 拒绝，已发生移动
    println!("{}, {}", v2.x, v2.y);
```
```rust
    #[derive(Clone, Copy)]  //  显式为结构体实现Copy
    struct Val {
        x: i32,
        y: f64,
    }

    let v1 = Val{x:1, y:3.14};      //  发生拷贝
    let v2 = v1;
    println!("{}, {}", v1.x, v1.y);     // 接受
    println!("{}, {}", v2.x, v2.y);
```
&nbsp;
## 2 引用语义
数据存放在**堆区**，使用栈区指针间接访问数据，称为**引用语义**。引用语句类型在赋值时将发生栈区指针拷贝，而堆区数据不变，称为**浅拷贝**。
以下类型是引用语义的：

| 引用语义类型 | 举例 |
| --- | ---- |
| 复合类型 |`String`<br>`Vector`<br>`HashMap`<br>...         |
|元素中含有引用语义类型的的元组|`(1, String::from("Hello"))`|
|元素中含有引用语义类型的数组|`[1, String::from("Hello")]`|
| 元素中含有引用语义类型的结构体     | `-` |
| 变体数据中含有引用语义类型的枚举   | `-` |

&nbsp;
### 2.1 移动
浅拷贝会导致多个指针指向同一块数据，这会带来很多内存安全问题，例如重复释放、垂悬指针、数据竞争等。在Rust中，引用语义赋值是不会发现简单的浅拷贝，而是会发生**所有权移动**来确保**一块内存必须被唯一的变量所拥有**的所有权规则。
- 移动 = 栈区指针拷贝 + 原变量标记为`moved`
- 被标记为`moved`的变量不能再被使用
```rust
    let s1 = String::from("hello");   //  引用语义类型
    let s2 = s1;    //  发生移动，s1被标记为movd
    println!("{s1}, {s2}");  // 拒绝，s1 不能再使用
```
&nbsp;
### 2.2 深拷贝
- 实现了`Clone`特质的引用语义类型支持进行深拷贝，生成一份新的数据
- 引用语义类型调用`clone()`方法进行深拷贝
- 深拷贝时，栈区指针和堆数据会同时发生拷贝，新的指针指向新的内存
- 深拷贝后的新数据与原数据完全独立，不违反所有权规则
```rust
    let s1 = String::from("hello");  
    let s2 = s1.clone();    //  深拷贝
    println!("{s1}, {s2}");  // 接受，访问的是两份独立的数据
```