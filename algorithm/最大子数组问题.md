# 最大子数组和问题
## 1 题目
给定一个数组`array`，它的子数组为数组`array`中连续的一段序列。求数组`array`的最大非空子数组和。

## 2 思路
### 2.1 拆解子问题，声明动态规划数组`dp[]`
声明动态规划数组`dp[]`, 长度与目标数组`array`相同，`dp[i]`表示以`array[i]`为开头的最大子数组和，并初始化`dp[]`的最后一个元素与`array[]`的最后一个元素相同
### 2.2 提供路径表示，声明路径数组`path[]`
动态规划数组`dp[]`的索引值就表示最大子数组的起点，还需要路径数组`path[]`表示最大子数组的终点。初始为`path[]`的最后一个元素为目标数组`array[]`的长度减1
### 2.3 动态规划
- 根据递推关系式，从能够确定初始值的位置遍历整个目标数组
- 递推过程中记录最大值
```rust
    //  从末尾往开头递推
    dp[i] = if dp[i + 1] > 0 { array[i] + dp[i + 1] } else { array[i] };
    path[i] = if dp[i + 1] > 0 { path[i + 1] } else { i };
```
### 2.4 递推结束，输出结果
`dp[]`中的最大元素即为最大字数组和，对应索引的`path[]`元素即为最大子数组末尾元素索引
### 2.5 示例
```rust
fn _max_continuous_subarray_literation1(array: &[i32]) -> (i32, (usize, usize)) {
    if array.is_empty() {
        panic!("Input array cannot be empty");
    }

    // 声明动态规划数组，长度匹配目标数组，统一初始化为目标数组的最后一个元素
    let mut dp = vec![*array.last().unwrap(); array.len()];

    // 声明路径数组，长度匹配目标数组，统一初始化为目标数组长度减1(最后一个元素的索引)
    let mut path = vec![array.len() - 1; array.len()];

    // 动态规划，从array倒数第二个元素开始遍历到开头
    // dp[i] = if dp[i + 1] > 0 { array[i] + dp[i + 1] } else { array[i] };
    // path[i] = if dp[i + 1] > 0 { path[i + 1] } else { i };
    let (mut start_index, mut max_sum) = (0, array[0]);
    for i in (0..array.len()).rev().skip(1) {
        dp[i] = if dp[i + 1] > 0 { array[i] + dp[i + 1] } else { array[i] };
        path[i] = if dp[i + 1] > 0 { path[i + 1] } else { i };
        if dp[i] > max_sum {
            (start_index, max_sum) = (i, dp[i]);
        }
    }
    // 递推结束，输出结果
    (max_sum, (start_index, path[start_index]))
}
```
## 3 优化
递推过程中，对于动态规划数组`dp[]`, 我们只关心它的上一个值`dp[i + 1]`和它的最大值，对于其他值是可以丢弃的。对于路径数组`path[]`, 我们只关心他的上一个值`path[i + 1]`, 和最大值的索引，对于其他值是可以丢弃的。可以使用滚动变量法进行优化，空间复杂度降为常数级。
```rust
fn _max_continuous_subarray_literation2(array: &[i32]) -> (i32, (usize, usize)) {
    if array.is_empty() {
        panic!("Input array cannot be empty");
    }

    //  声明并初始化动态规划滚动变量
    // 使用滚动变量法进行改进，空间复杂度优化到常数级
    // dp[i] => current_sum
    // path[i] => end, temp_end
    let tail_index = array.len() - 1;
    let (mut max_sum, mut current_sum) = (array[tail_index], array[tail_index]);
    let (mut start, mut end, mut temp_end) = (tail_index, tail_index, tail_index);

    // 动态规划，从array倒数第二个元素开始遍历到开头
    // dp[i] = array[i] + dp[i + 1]  ==>    current_sum += num;
    //        path[i] = path[i + 1]  ==>    直接消去
    //             dp[i] = array[i]  ==>    current_sum = num
    //                 path[i] = i   ==>    temp_end = i;
    for (i, &num) in array.iter().enumerate().rev().skip(1) {
        temp_end = if current_sum > 0 { temp_end } else { i };
        current_sum = if current_sum > 0 { current_sum + num } else { num };

        if current_sum > max_sum {  //  此处可添加边界以获得最长或者最短的字串(多解情况)
            max_sum = current_sum;
            start = i;
            end = temp_end;
        }
    };
    (max_sum, (start, end))
}
```
再进一步优化，可以改成从数组头递推
```rust
pub fn max_continuous_subarray(array: &[i32]) -> (i32, (usize, usize)) {
    if array.is_empty() {
        panic!("Input array cannot be empty");
    }

    //  声明并初始化动态规划滚动变量
    // 使用滚动变量法进行改进，空间复杂度优化到常数级
    let (mut max_sum, mut cur_sum) = (array[0], array[0]);
    let (mut start, mut end, mut temp_start) = (0, 0, 0);

    for (i, &num) in array.iter().enumerate().skip(1) {
        if cur_sum > 0 {
            cur_sum += num;
        } else {
            cur_sum = num;
            temp_start = i;
        }
        if cur_sum > max_sum {  //  此处可添加边界以获得最长或者最短的字串(多解情况)
            max_sum = cur_sum;
            end = i;
            start = temp_start;
        }
    };
    (max_sum, (start, end))
}
```